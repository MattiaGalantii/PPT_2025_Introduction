# {{< fa brands python >}} Python Recap
This section provides a brief recap of essential Python concepts and libraries that will be useful throughout the course.  
You should already be familiar with these topics, but this serves as a quick refresher.

::: {.nonincremental}
>
- Native Data Structures
- Control Structures and Functions
- Classes and Object Oriented Programming (OOP)
:::

## Native Data Structures {transition="slide-in none-out"}
Python offers several built-in data structures that are fundamental for programming:

::: {.fragment}
### **Lists:** Ordered, mutable collections of items. 
Example: 
``` {.python code-line-numbers="1-3|4-5|1-5"}
my_list_of_numbers = [1, 2, 3]
my_list_of_strings = ["apple", "banana", "cherry"]
my_list_of_booleans = [True, False, True]
my_list_of_lists = [[1, 2], [3, 4, 5], []]
my_heterogeneous_list = [1, "apple", 3.14, True, [1, 2], {"a": 1}]
```
:::
::: {.fragment}
[Lists]{.py-green} can be *heterogeneous* (contain elements of different types), but **whenever possible** itâ€™s best to keep them *homogeneous* (containing elements of the same type) for easier processing and compatibility with libraries like NumPy.
:::

---

## Native Data Structures {transition="none-in none-out"}
Python offers several built-in data structures that are fundamental for programming:

::: {.fragment}
### **Tuples:** Ordered, immutable collections of items. {transition="fade"}
Example: 
```{.python}
my_tuple = (1, 2, 3)
coordinate_point = (3, 4)                  
record = ("COâ‚‚", 44.01, "g/mol") 
```
:::
::: {.fragment}
Use [tuples]{.py-green} when you want to ensure that the data **cannot** be modified after creation, or to group related but different types of data together.
:::

::: {.fragment}
::: {.callout-caution} 
Tuples are immutable! Once created, you cannot change their values.
```{python} 
#| echo: true
#| output-location: fragment
#| error: true
my_tuple = (1, 2, 3)
my_tuple[0] = 10                 
```
::: 
:::

---

## Native Data Structures {transition="none-in slide-out"}
Python offers several built-in data structures that are fundamental for programming:

::: {.fragment}
### **Dictionaries:** Key-value pairs for storing data.
```{.python}
my_dict = {'a': 1, 'b': [1, 2, 3], 'c': 'hello'}
exams_I_passed = {
    'Numerical Methods': True,
    'Physical Transport Phenomena': False,
    'Chemical Reactors': True,
    'Practicum Process Technology': nan
}
```
:::
::: {.fragment}
[Dictionaries]{.py-green} are useful for representing structured data and allow for efficient data retrieval using keys.
```{python}
#| echo: true
#| output-location: fragment    
molecular_weights = {
    'H2O': 18.015,
    'CO2': 44.01,
    'CH4': 16.04
}
print(f"Molecular weight of CO2: {molecular_weights['CO2']}")
```
:::


## Control Structures and Functions {transition="slide-in none-out"}
Control structures and functions are essential for controlling the flow of a program and organizing code into reusable blocks.

::: {.fragment}
### **If-Else Statements:**
 Conditional execution of code blocks.
```{python}
#| echo: true
#| output-location: fragment
temperature = 10
if temperature > 30:
    print("It's hot outside!")
elif temperature < 15:
    print("It's cold outside") 
else:
    print("The weather is moderate.")
```
:::

---

## Control Structures and Functions {transition="none-in none-out"}

Control structures and functions are essential for controlling the flow of a program and organizing code into reusable blocks.

::: {.fragment}
### **For Loops:** 
Iterating over sequences (like lists or ranges).
```{python}
#| echo: true
#| output-location: fragment
for iter in range(5):
    print(f"Iteration {iter}")
```
:::

::: {.fragment}
::: {.callout-tip}
Check out lists comprehensions for a more concise way to create lists using for loops:
```{python}
#| echo: true
#| output-location: fragment
squares = [x**2 for x in range(10)]
print("Squares from 0 to 9:", squares)
```
:::
:::
---

## Control Structures and Functions  {transition="none-in none-out"}
Control structures and functions are essential for controlling the flow of a program and organizing code into reusable blocks.

::: {.fragment}
### **While Loops:** 
Repeating a block of code while a condition is true.
```{python}
#| echo: true
#| output-location: fragment
count = 0
while count < 5:
    print(f"Count is {count}")
    count += 1
```
:::     

---

## Control Structures and Functions {transition="none-in slide-out"}
Control structures and functions are essential for controlling the flow of a program and organizing code into reusable blocks. 

::: {.fragment}
### **Functions:** 
Reusable blocks of code that perform a specific task. 
```{python}
#| echo: true
#| output-location: fragment
def this_function_is_kind(name):
    return f"Hello, {name}, nice to see you again!"

my_name = "Mattia"
print(this_function_is_kind(my_name))
```
:::
::: {.fragment}
Functions help in organizing code, improving readability, efficiency, and avoiding repetition.
 
::: {.callout-important}
They are going to be extensively used throughout this course, **so make sure you are comfortable with them.** 
:::
:::

::: footer
Refresh your knowledge on functions:  
[Python Functions](https://www.geeksforgeeks.org/python/python-functions/)   
[Defining Your Own Python Function](https://realpython.com/defining-your-own-python-function/)
:::

## **Classes:** 
Sometimes, you may end up with many functions and data that are related to each other. In such cases, it is often useful to group them together into a single unit called a class.

A class is a *blueprint* for creating objects that share common properties and behaviors.

::: {.fragment}
```{.python code-line-numbers="|1-6|8-18|20|21-23"}
class Cat:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color
        self.cuteness_level = 999999999999

    def purr(self):
        print("Purr... ðŸ˜ºðŸ’¤")
        return 

    def scratch(self):
        print("Scratch! ðŸ˜¾ðŸ’¢")
        return

    def unleash_cuteness(self):
        print("Awwwwwwwwwww!! SOOOO CUTE!!! ðŸ˜»âœ¨ðŸ’–")
        return

my_cat = Cat("Arturo", 2, "Gray")
my_cat.purr()
my_cat.scratch()
my_cat.unleash_cuteness()
```
:::
::: {.fragment}
```{python code-line-numbers="|11|12-13"}
#| echo: false
class Cat:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color
        self.cuteness_level = 999999999999

    def purr(self):
        return print("Purr... ðŸ˜ºðŸ’¤")

    def scratch(self):
        return print("Scratch! ðŸ˜¾ðŸ’¢")

    def unleash_cuteness(self):
        return print("Awwwwwwwwwww!! SOOOO CUTE!!! ðŸ˜»âœ¨ðŸ’–")

my_cat = Cat("Arturo", 2, "Gray")
my_cat.purr()
my_cat.scratch()
my_cat.unleash_cuteness()
```
:::

---

### Is it necessary to use classes?

::: {.nonincremental}
- **Classes** are the foundation of *object-oriented programming (OOP)*, used to group related data and behavior.  
- They help in **organizing**, **maintaining**, and **modularizing** the code, especially in large projects.
- Most modern Python libraries (e.g., `NumPy`, `pandas`, `TensorFlow`) rely **heavily** on classes. Understanding them helps you navigate and extend such frameworks.   
:::

::: {.fragment}
>- In this course, you're free to use functions and native data structures as much as you want. However, learning about classes will be *beneficial* for your overall programming skills. Therefore, we encourage you to explore and understand them as you progress through the course.
:::  

::: footer
Learn more about classes:  
[The power of classes](https://realpython.com/python-classes/)   
[Object-oriented programming in Python](https://realpython.com/python3-object-oriented-programming/)
:::

